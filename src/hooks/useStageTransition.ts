import { useCallback } from 'react';
import { PipelineStage, PIPELINE_STAGES, Task, Project } from '@/types';
import { useNotifications } from '@/context/NotificationContext';
import { toast } from 'sonner';

interface StageTransitionResult {
  handleStageChange: (project: Project, newStage: PipelineStage) => {
    updatedProject: Project;
    autoTasks: Task[];
  };
  getStageTaskTemplates: (stage: PipelineStage) => { title: string; description: string; priority: Task['priority'] }[];
}

// Task templates for each stage
const stageTaskTemplates: Record<PipelineStage, { title: string; description: string; priority: Task['priority'] }[]> = {
  initiation: [
    { title: 'Initial Client Meeting', description: 'Schedule and conduct initial meeting with client', priority: 'high' },
    { title: 'Gather Requirements', description: 'Document initial project requirements', priority: 'high' },
  ],
  qualification: [
    { title: 'Technical Assessment', description: 'Evaluate technical feasibility', priority: 'high' },
    { title: 'Budget Estimation', description: 'Prepare preliminary budget estimate', priority: 'medium' },
    { title: 'Stakeholder Identification', description: 'Identify all project stakeholders', priority: 'medium' },
  ],
  proposal: [
    { title: 'Draft Proposal', description: 'Create detailed project proposal', priority: 'urgent' },
    { title: 'Internal Review', description: 'Submit proposal for internal review', priority: 'high' },
    { title: 'Client Presentation', description: 'Present proposal to client', priority: 'high' },
  ],
  negotiation: [
    { title: 'Terms Discussion', description: 'Negotiate contract terms with client', priority: 'high' },
    { title: 'Pricing Finalization', description: 'Finalize pricing and payment terms', priority: 'urgent' },
    { title: 'Legal Review', description: 'Submit contract for legal review', priority: 'high' },
  ],
  approval: [
    { title: 'Final Approval Meeting', description: 'Conduct final approval meeting', priority: 'urgent' },
    { title: 'Sign Off Documentation', description: 'Prepare sign-off documentation', priority: 'high' },
    { title: 'Resource Allocation', description: 'Allocate resources for project execution', priority: 'medium' },
  ],
  execution: [
    { title: 'Project Kickoff', description: 'Conduct project kickoff meeting with all stakeholders', priority: 'urgent' },
    { title: 'Resource Mobilization', description: 'Mobilize team and resources for project execution', priority: 'high' },
    { title: 'Progress Tracking Setup', description: 'Set up project tracking and reporting mechanisms', priority: 'high' },
  ],
  closure: [
    { title: 'Contract Signing', description: 'Complete contract signing process', priority: 'urgent' },
    { title: 'Kick-off Planning', description: 'Plan project kick-off meeting', priority: 'high' },
    { title: 'Handover to Delivery', description: 'Hand over project to delivery team', priority: 'high' },
  ],
};

export function useStageTransition(): StageTransitionResult {
  const { addNotification } = useNotifications();

  const getStageTaskTemplates = useCallback((stage: PipelineStage) => {
    return stageTaskTemplates[stage] || [];
  }, []);

  const handleStageChange = useCallback((project: Project, newStage: PipelineStage) => {
    const currentStageIndex = PIPELINE_STAGES.findIndex(s => s.value === project.pipelineStage);
    const newStageIndex = PIPELINE_STAGES.findIndex(s => s.value === newStage);
    const stageName = PIPELINE_STAGES.find(s => s.value === newStage)?.label || newStage;

    // Create auto-generated tasks for the new stage
    const templates = stageTaskTemplates[newStage] || [];
    const autoTasks: Task[] = templates.map((template, index) => ({
      id: `auto-task-${project.id}-${newStage}-${index}-${Date.now()}`,
      title: template.title,
      description: template.description,
      status: 'todo',
      priority: template.priority,
      projectId: project.id,
      createdAt: new Date().toISOString(),
      dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      isAutoGenerated: true,
      stageTriggered: newStage,
    }));

    // Update project with new stage
    const updatedProject: Project = {
      ...project,
      pipelineStage: newStage,
      lastStageUpdate: new Date().toISOString(),
      stageHistory: [
        ...(project.stageHistory || []),
        {
          stage: project.pipelineStage,
          enteredAt: project.lastStageUpdate || project.startDate,
          exitedAt: new Date().toISOString(),
        },
      ],
      tasks: [...project.tasks, ...autoTasks],
    };

    // Add notification
    const direction = newStageIndex > currentStageIndex ? 'moved forward to' : 'moved back to';
    addNotification({
      type: 'stage_change',
      title: `Stage Changed: ${project.name}`,
      message: `Project ${direction} ${stageName} stage. ${autoTasks.length} tasks auto-created.`,
    });

    // Show toast
    toast.success(`Project moved to ${stageName} stage`, {
      description: `${autoTasks.length} tasks have been automatically created for this stage.`,
    });

    return { updatedProject, autoTasks };
  }, [addNotification]);

  return { handleStageChange, getStageTaskTemplates };
}

// Utility function to check for inactive projects (3+ days without stage update)
export function checkInactiveProjects(projects: Project[]): Project[] {
  const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
  return projects.filter(p => 
    p.status === 'active' && 
    p.lastStageUpdate && 
    new Date(p.lastStageUpdate) < threeDaysAgo &&
    p.pipelineStage !== 'closure'
  );
}
